# DataType

- javascript의 타입은 크게 두 가지로 분류된다.
- Primitive Type(기본형)
- Reference Type(참조형)

## Primitive Type(기본형)

- 기본형에는 Number, String, Boolean, null, undefined, Symbol 총 6가지가 있다.
  - Symbol은 ES6에 추가된 타입이다.

## Reference Type(참조형)

- 참조형에는 Object(객체)가 있으며 그 하위에는 Array, Function, RegExp, Set/WeakSet, Map/WeakMap 등이 있다.
  - Object
    - Array
    - Function
    - RegExp (정규표현식)
      (이 아래는 ES6에서 추가된 타입)
    - Set/WeakSet
    - Map/WeakMap
    - ....

> javascript의 메모리 구조
>
> > **Stack memory**  
> > 변수 / 기본형 데이터 / 정적할당  
> > 변수와 함께 기본형 데이터가 저장된다.<br><br> >> **Heap memory**  
> > 참조형 데이터 / 동적할당  
> > 참조형 데이터가 저장된다.

## Primitive Type의 데이터 할당 기본 순서

```js
var a;
```

각 셀이 하나하나의 메모리라고 가정할 때, `a`를 선언하면 메모리에 데이터가 담길 공간을 미리 확보한다. 지금의 경우 임의로 1003 주소에 데이터를 담는다고 가정한다.
| 주소 | ... | 1002 | 1003 | 1004 | 1005 | ... |
|---|:---:|:---:|:---|:---:|:---:|---:|
| | | |이름: a <br> 값: | | | |

| 주소 | ... | 5002 | 5003           | 5004 | 5005 | ... |
| ---- | :-: | :--: | :------------- | :--: | :--: | --: |
|      |     |      | 이름: <br> 값: |      |      |     |

---

```js
var a;
a = "abc";
```

`a`에 `'abc'`를 대입하게 되면 컴퓨터는 또 다른 비어있는 메모리 공간에 값을 저장한다. 지금의 경우 5004에 값을 저장한다.
| 주소 | ... | 1002 | 1003 | 1004 | 1005 | ... |
|---|:---:|:---:|:---|:---:|:---:|---:|
| | | |이름: a <br> 값: | | | |

| 주소 | ... | 5002 | 5003 | 5004  | 5005 | ... |
| ---- | :-: | :--: | :--- | :---: | :--: | --: |
|      |     |      |      | 'abc' |      |     |

---

```js
var a;
a = "abc";
```

이렇게 5004 주소에 값을 저장한 상태로 컴퓨터는 변수 `a`를 찾아 값이 들어있는 주소들을 검색하다가 식별자가 a인 1003번의 주소를 찾아 그 값이 든 메모리의 주소인 5004를 넣게된다.
| 주소 | ... | 1002 | 1003 | 1004 | 1005 | ... |
|---|:---:|:---:|:---|:---:|:---:|---:|
| | | |이름: a <br> 값:**@5004** | | | |

| 주소 | ... | 5002 | 5003 | 5004  | 5005 | ... |
| ---- | :-: | :--: | :--- | :---: | :--: | --: |
|      |     |      |      | 'abc' |      |     |

---

```js
var a;
a = "abc";
a = "abcdef";
```

이후 다시 변수 `a`에 'abcdef'를 넣으라고 한다면 컴퓨터는 다시 비어있는 메모리의 임의 공간에 값을 저장하고 해당 값을 대입할 식별자 a를 찾아 검색하여 그 값이 든 메모리의 주소인 '5005'를 넣게된다.
| 주소 | ... | 1002 | 1003 | 1004 | 1005 | ... |
|---|:---:|:---:|:---|:---:|:---:|---:|
| | | |이름: a <br> 값:**@5005** | | | |

| 주소 | ... | 5002 | 5003 | 5004  |   5005   | ... |
| ---- | :-: | :--: | :--- | :---- | :------: | --: |
|      |     |      |      | 'abc' | 'abcdef' |     |

## Reference Type의 데이터 할당 기본 순서

```js
var obj = {
  a: 1,
  b: "bbb",
};
```

해당 객체로 선언과 동시에 값이 대입되져 있는 경우, 컴퓨터는 아래와 같이 선언 후, 값이 대입하는 순서로 동작하게 된다.

```js
var = obj;
obj = {
    a: 1,
    b: 'bbb'
};
```

`obj`를 선언하면 비어있는 임의의 메모리 공간에 obj를 할당한다. 지금의 경우 1002에 할당한다.  
값을 넣어야 하는데, 메모리 구조 공간에는 값이 하나씩 밖에 들어갈 수 없어 객체 자체를 메모리 하나에 할당할 수 없다.  
값을 넣어 줄 공간인 5002 주소에서는 7103 주소부터 메모리를 충분히 확보를 해두고, 확보된 공간의 데이터를 이 객체안의 프로퍼티라고 지정을 해준다.
확보된 공간에 프로퍼티를 하나씩 할당을 해주게 된다.  
| 주소 | ... | 1002 | 1003 | 1004 | ... |
| ---- | :-: | :-------------------------: | :--- | :--: | --: |
| | | 이름: obj <br> 값:**@5002** | | | |

| 주소 | ... |   5002    | 5003 | 5004  | 5005 | ... |
| ---- | :-: | :-------: | :--: | :---: | :--: | :-: |
|      |     | @7103 ~ ? |  1   | 'bbb' |      |     |

| 주소 | ... |          7103          |          7104          | 7105 | ... |
| ---- | :-: | :--------------------: | :--------------------: | :--: | :-: |
|      |     | 이름: a <br> 값: @5003 | 이름: b <br> 값: @5004 |      |     |

---

```js
var = obj;
obj = {
    a: 1,
    b: 'bbb'
};
obj.a = 2;
```

이후의 `obj.a`의 공간에 2를 할당하라고 한다면, 컴퓨터는 비어있는 메모리에 2를 저장하게 된다. 5005 주소에 저장한 2를 hold 하고, 이제 `obj.a`의 프로퍼티를 찾으려 `obj`객체를 찾게 되고, `obj`를 가리키는 1002번 주소로 찾아가 값이 든 5002번 주소로 찾아가고, 5002번 주소에서 확보해놓은 7103 ~ ?주소로 이동한 다음에 값이 든 메모리를 검색해서 식별자가 a인 주소인 7103주소가 가리키는 값을 2가 든 주소인 5005로 변경해준다.
| 주소 | ... | 1002 | 1003 | 1004 | ... |
| ---- | :-: | :-------------------------: | :--- | :--: | --: |
| | | 이름: obj <br> 값:**@5002** | | | |

| 주소 | ... |   5002    | 5003 | 5004  | 5005 | ... |
| ---- | :-: | :-------: | :--: | :---: | :--: | :-: |
|      |     | @7103 ~ ? |  1   | 'bbb' |  2   |     |

| 주소 | ... |          7103          |          7104          | 7105 | ... |
| ---- | :-: | :--------------------: | :--------------------: | :--: | :-: |
|      |     | 이름: a <br> 값: @5005 | 이름: b <br> 값: @5004 |      |     |

이렇게 값이 변경되었어도 dbj를 가리키는 값인 주소인 @5002는 변경되지 않았다. 이는 **기본형 데이터와 달리 참조형 데이터는 메모리 할당 과정을 1단계 더 거치기 때문에 참조형은 값이 변하지 않는 것**이다.

## 중첩 객체의 데이터 할당 기본 순서

```js
var obj = {
  x: 3,
  arr: [3, 4],
};
```

중첩 객체는 참조형 데이터 할당과 비슷하게 진행된다. `obj`의 메모리 공간을 할당하고, `obj`의 값을 가리키는 주소인 @5002를 값으로 불러온다.  
5002는 객체의 값을 저장하기 위해서 프로퍼티에 값을 할당해줄 공간을 @7103 ~ ? 까지 확보를 하고 그 안에 x의 값과 arr의 값을 담는다. 여기서 x의 값은 *@5003*에 저장된 3을 가져온다.  
`arr`은 배열이므로 이 또한 참조형 데이터이다. 배열은 **가변적인 데이터 그룹**으로, 메모리 공간을 객체 `obj`와 동일하게 여유롭게 확보한 후, 해당 메모리 안에 값을 저장한다.  
지금의 경우 메모리 공간을 *@8104 ~ ?*를 확보한 후, 8104에는 저장된 인덱스 0의 값을 불러오는데, 이미 메모리상에 3이라는 값이 저장되어있는 메모리가 있으므로, *@5003*의 값을 가져온다. 4의 값은 저장되어있는 것이 없으므로, *@5004*라는 새로운 메모리에 4라는 값을 불러와서 값을 저장한다.

| 주소 | ... |            1002             | 1003 | 1004 | ... |
| ---- | :-: | :-------------------------: | :--- | :--: | --: |
|      |     | 이름: obj <br> 값:**@5002** |      |      |     |

| 주소 | ... |   5002    | 5003 |   5004    | 5005 | ... |
| ---- | :-: | :-------: | :--: | :-------: | :--: | :-: |
|      |     | @7103 ~ ? |  3   | @8104 ~ ? |  4   |     |

| 주소 | ... |          7103          |           7104           | 7105 | ... |
| ---- | :-: | :--------------------: | :----------------------: | :--: | :-: |
|      |     | 이름: x <br> 값: @5003 | 이름: arr <br> 값: @5004 |      |     |

| 주소 | ... |          8104          |          8105          | 8106 | ... |
| ---- | :-: | :--------------------: | :--------------------: | :--: | :-: |
|      |     | 이름: 0 <br> 값: @5003 | 이름: 1 <br> 값: @5005 |      |     |

---

> 참조 카운트? 가비지 컬렉터?
>
> > **참조카운트?** <br> 참조 카운트란, 참조하고 있는 대상을 숫자로 표현하는 것을 말한다. <br><br> >> **가비지 컬렉터?**

```js
var obj = {
  x: 3,
  arr: [3, 4],
};
obj.arr = "str";
```

여기서 `obj.arr`의 값이 'str'로 변경된다면 우선 'str'이라는 값을 새롭게 메모리에 저장하게된다.  
이렇게 저장된 값을 *@7104*가 가리키는 값으로 변경하게 되고 기존에 배열의 값을 가리키던 *@5004*를 가리키는 대상이 사리지게 된다. 이때, **참조 카운트**가 0이 되었다고 표현한다.  
참조 카운트가 0인 메모리는 가비지 컬렉터의 수집 대상이 되어 저장된 값이 사라지게 된다. 때문에 참조를 받지 못하는 *@5004*와 @5004가 참조하고 있던 *@8104 ~ ?*까지 연쇄적으로 가비지 컬렉터의 수집대상이 되어 같이 사라지게 된다.

| 주소 | ... |            1002             | 1003 | 1004 | ... |
| ---- | :-: | :-------------------------: | :--- | :--: | --: |
|      |     | 이름: obj <br> 값:**@5002** |      |      |     |

| 주소 | ... |   5002    | 5003 |         5004          | 5005 | 5006  | ... |
| ---- | :-: | :-------: | :--: | :-------------------: | :--: | :---: | --- |
|      |     | @7103 ~ ? |  3   | **GB** <br> @8104 ~ ? |  4   | 'str' |     |

| 주소 | ... |          7103          |             7104             | 7105 | ... |
| ---- | :-: | :--------------------: | :--------------------------: | :--: | :-: |
|      |     | 이름: x <br> 값: @5003 | 이름: arr <br> 값: **@5006** |      |     |

| 주소 | ... |                8104                |                8105                | 8106 | ... |
| ---- | :-: | :--------------------------------: | :--------------------------------: | :--: | :-: |
|      |     | **GB** <br> 이름: 0 <br> 값: @5003 | **GB** <br> 이름: 1 <br> 값: @5005 |      |     |

# 값을 직접 저장하는 방식과 값의 주소를 저장하는 방식의 차이점

## 값을 직접 저장

- 데이터 할당시에는 빠름
- 비교에 비용이 많이 듬
- 메모리 낭비가 심함

| 주소 | ... |                         1002                          | 1003 | 1004 | ... |
| ---- | :-: | :---------------------------------------------------: | :--- | :--: | --: |
|      |     | 이름: x <br> 값: 대충 세어봐도 30바이트가 넘는 문자열 |      |      |     |

| 주소 | ... |                         5002                          | 5003 | 5004 | ... |
| ---- | :-: | :---------------------------------------------------: | :--: | :--: | --- |
|      |     | 이름: 0 <br> 값: 대충 세어봐도 30바이트가 넘는 문자열 |      |      |     |

### 약 30 \* x byte의 메모리 필요

---

## 값의 주소를 저장

- 데이터 할당시에는 느림
- 비교에 비용이 들지 않음
- 메모리 낭비 최소화

| 주소 | ... |           1002            | 1003                                 | 1004 | ... |
| ---- | :-: | :-----------------------: | :----------------------------------- | :--: | --: |
|      |     | 이름: x <br> 값:**@1003** | 대충 세어봐도 30바이트가 넘는 문자열 |      |     |

| 주소 | ... |            5002            | 5003 | 5004 | ... |
| ---- | :-: | :------------------------: | :--: | :--: | --- |
|      |     | 이름: 0 <br> 값: **@1003** |      |      |     |

### 약 30 + X byte의 메모리 필요

> **불변값?** <br>
> 위에서 값의 주소를 지정함으로써 비교의 비용이 들지 않는다라고 하였다.  
> 그 의미는 같은 값은 전체 메모리 공간 상에 오직 하나만 존재한다는 의미이고, 이 것이 곧 불변값임을 의미하는 것이다.
>
> > 기본형 데이터는 불변값이라고 한다.

# 변수 복사

```js
var a = 10;
var b = a;
var obj1 = { c: 10, d: "ddd" };
var obj2 = obj1;
```

변수 `a`는 10의 값이 저장되어 있는 *@5002*의 값을 가리킨다. 변수 `b`는 `a`의 값을 대입하므로 `a`의 값이 저장되어있는 *@5002*를 값으로 가리킨다.  
변수 `obj1`은 객체를 값으로 저장하므로 충분한 메모리를 할당하고 그 메모리를 할당한 주소인 *@5003*을 가리킨다. 할당된 메모리인 *@7103*에 `c`를 선언하고 `c`의 값은 10이므로, 미리 10이라는 값이 저장되어있던 주소인 *@5002*를 값으로 가리킨다. `d`의 값은 문자열 'ddd'이므로 저장된 값이 없으니 빈 메모리에 새롭게 저장하여 저장된 주소인 *@5004*를 가리키게 된다. 변수 `obj2`는 `obj1`의 값을 대입하므로 `obj1`의 값이 저장되어 있는 *@5003*을 값으로 가리킨다.

| 주소 | ... |         1002          | 1003                  |           1004           |           1005           | ... |
| ---- | :-: | :-------------------: | :-------------------- | :----------------------: | :----------------------: | --: |
|      |     | 이름: a <br> 값:@5002 | 이름: b <br> 값:@5002 | 이름: obj1 <br> 값:@5003 | 이름: obj2 <br> 값:@5003 |     |

| 주소 | ... | 5002 | 5003      | 5004  | 5005 | ... |
| ---- | :-: | :--: | :-------- | :---: | :--: | --: |
|      |     |  10  | @7103 ~ ? | 'ddd' |      |     |

| 주소 | ... |          7103          | 7104                   | 7105 | 7106 | ... |
| ---- | :-: | :--------------------: | :--------------------- | :--: | :--: | --: |
|      |     | 이름: c <br> 값: @5002 | 이름: d <br> 값: @5004 |      |      |     |

## 기본형과 참조형의 차이점

- 기본형은 값을 직접 가리키고 있기 때문에 같은 값을 가리키고 있던 변수라도 값이 바뀌면 서로 가리키고 있는 주소가 달라지는 반면에,  
  참조형은 가리키고 있는 값에서 한 번 더 메모리를 할당하는 과정을 거치기 때문에, 객체의 값을 바꿨을 때는 여전히 두 변수 다 같은 객체를 가리키고 있는 것이다.
- `obj1`의 객체를 복사하던 `obj2.c`의 값을 변경하면 `obj1`의 객체도 변경된 것을 확인할 수 있다.

```js
var a = 10;
var b = a;
var obj1 = { c: 10, d: "ddd" };
var obj2 = obj1;

b = 15;
obj2.c = 20;
```

| 주소 | ... |         1002          |           1003            |           1004           |           1005           | ... |
| ---- | :-: | :-------------------: | :-----------------------: | :----------------------: | :----------------------: | --: |
|      |     | 이름: a <br> 값:@5002 | 이름: b <br> 값:**@5005** | 이름: obj1 <br> 값:@5003 | 이름: obj2 <br> 값:@5003 |     |

| 주소 | ... | 5002 |   5003    | 5004  | 5005 | 5006 | ... |
| ---- | :-: | :--: | :-------: | :---: | :--: | :--: | --: |
|      |     |  10  | @7103 ~ ? | 'ddd' |  15  |  20  |     |

| 주소 | ... |            7103            |          7104          | 7105 | 7106 | ... |
| ---- | :-: | :------------------------: | :--------------------: | :--: | :--: | --: |
|      |     | 이름: c <br> 값: **@5006** | 이름: d <br> 값: @5004 |      |      |     |
