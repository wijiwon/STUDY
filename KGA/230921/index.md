# 이더리움 개발

## 이더리움으로 개발하기 위해 필요한 개념

- block : 트랜잭션 및 데이터를 모아서 하나의 블록에 저장한다.

- Account : EOA와 CA의 두 개념이 있다.

  - EOA는 토이 비트코인에서 만들었던 개인키가 존재하는 어카운트.
  - CA는 컨트랙트 코드에 의해 제어되는 스마트 컨트랙트 어카운트.

- Message or Transaction : 트랜잭션은 메시지의 수신자가 이더를 보낼 때.

- ETH : 이더리움 네트워크에서 사용하는 암호화폐의 기본 단위

# 이더리움 개발할 때 사용하는 툴

1. geth : go언어로 작성이 되어있는 이더리움 클라이언트. chainID를 확인할 수 있는 클라이언트

   - chainID : 블록체인의 고유 식별자. 메인넷인지 테스트넷인지 구분할 수 있다.

2. Ganache : 로컬 개발 및 테스트 환경을 제공해준다. (이더리움 네트워크)

3. 파운드리 : 솔리디티 테스트 코드를 작성할 수 있다. TDD 구현 가능

4. 메타마스크 : 브라우저의 확장 프로그램으로 웹 어플리케이션에서 이더리움 스마트 컨트랙트와 상호 작용할 수 있도록 도와준다.

   - 개인키의 관리, 트랜잭션을 생성하면 서명을 네트워크에 전달할 수 있다.

5. Truffle, Hardhat : 스마트 컨트랙트 개발, 테스트 배포를 쉽게할 수 있도록 도와주는 프레임 워크이다.

# Ganache : 로컬 개발 테스트 (이더리움 네트워크)

## RPC (Remote Prcedure Call)

- 별도의 원격 제어를 위한 코딩을 하지 않고, 다른 주소 공간에 프로시저를 실행할 수 있게 하는 프로세스 간의 통신을 말한다.

- 함수의 경우 입력(inpput)에 따른 출력(output)이 발생을 목적으로 한다.
  - 반환값을 필수로 가져야하며, 클라이언트에서 처리를 하고 연산작업이나 수치가 필요할 경우 사용한다.
- 프로시저의 경우 출력값에 집중하기 보다는 `명령의 단위가 수행하는 절차`이다.
  - 때문에 반환값이 있을 수도, 없을 수도 있으며, 서버단에서 처리한다.

### RPC 통신을 언제 사용할까?

- 일반적으로 우리가 코드를 작성하고 프로그램을 실행시키면 자신의 메모리 공간에서 기능을 수행하며 함수가 실행된다.
- RPC 통신 다른 주소에 있는 함수를 실행시킬 때 사용한다.
- 즉, RPC 통신은 자신과 다른 주소의 메모리 공간에서 동작하는 프로세스의 함수를 실행할 수 있게 해주는 통신이다.

- RPC 통신을 사용하면 생기는 장점은 다음과 같다.
  - 비즈니스 로직을 개발하는데 집중할 수 있다.

# Ganache 설치

설치

- npm i -g ganache-cli
  실행(터미널)
- npx ganache-cli

# RPC를 이용해서 함수 호출

```json
{
  "jsonrpc": "2.0", // json-RPC 버전 2.0
  "method": "web3_clientVersion", // 실행 요청할 메서드 명
  "params": [] // 메서드에 전달을 할 인자값. 매개변수
}
```

- curl
- cli에서 요청을 보낼 수 있다.
- bash에서 실행
- curl -X POST -d '{"jsonrpc" : "2.0", "method": "web3_clientVersion", "params": []}' http://127.0.0.1:8545

  - -X POST : get인지 post인지 등의 요청 타입
  - -d `{"jsonrpc" : "2.0", "method": "web3_clientVersion", "params": []}` : 전달하는 데이터의 내용
  - http://127.0.0.1:8545 : 요청하는 URL

- ganache로 이더리움 네트워크 테스트 환경에서
- web3_clientVersion 메서드를 실행시키는데
- RPC 통신으로 요청을 보내서
- 네트워크의 web3_clientVersion 메서드를 실행시키고
- 반환받은 메시지는 {"jsonrpc":"2.0","result":"EthereumJS TestRPC/v2.13.2/ethereum-js"}
- EthereumJS TestRPC/v2.13.2/ethereum-js

- eth_gatBalance(매개변수)
- curl -X POST -d '{"jsonrpc" : "2.0", "method" : "eth_getBalance", "params" : ["0xC82148d0B33862163E3E83F574099F14C29d670a"] }' http://127.0.0.1:8545
- eth_gatBalance 함수를 RPC 통신으로 요청을 해서
- 계정의 잔액
- {"jsonrpc":"2.0","result":"0x56bc75e2d63100000"}
- web3에서는 gatBalance 호출을 하면 10진수로 변환해서 반환 값을 주고
- wei 단위에서 eth 단위로 변경을 하려면, 1eth === 100 x 10e18 wei
- wei = 10xx18

# 이더리움 트랜잭션을 발생 시킬 때 gas

- 주유소를 예를 들어서, 리터 당 2000원이라는 상황에서 4만원을 넣는다고 가정하면 20리터를 넣을 수 있다.
- 리터 == gasPrice : 리터 당의 가격 (2000원)
- gas : 총 가스량(== 가스의 리터 당으로 계산한 총 가스량의 값)에서 우리가 발생시킬 수 있는 총 제한량

- 트랜잭션 발생 시 총 수수료는 gas x gasPrice
- byte당 대략 5gas

# sendTransaction

- curl -X POST -d '{"jsonrpc" : "2.0", "method" : "eth_sendTransaction", "params" : [{"from" : "0xC82148d0B33862163E3E83F574099F14C29d670a","to" : "0x5020C5Bdb003413bF8a9DbFDE3D3A2259c7b823b","value": "10000000000"}]}' http://127.0.0.1:8545

# web3

- js 라이브러리로, 웹 어플리케이션에서 이더리움 블록체인과 상호작용 하기 위해 노드에서 요청을 보낼 때, API를 지정해놓은 것이다.

# 간단하게 컨트랙트를 배포해보자

- 소스 코드 작성에 사용하는 언어 : 솔리디티를 사용할 것이다.

- 컴파일 -> EVM이 실행시킬 수 있는 형식(바이트 코드)으로 변환

- 배포 -> 트랜잭션 생성. 변환한 바이트 코드와 내용을 포함한 트랜잭션을 생성하고 이더리움 네트워크에 전송
- 네트워크 트랜잭션 풀에 담기고 블록이 생성되면서 데이터로 저장된다. => 이것이 스마트 컨트랙트 배포이다.

# 기본적인 솔리디티 코드 구조

1. 라이센스 식별자
2. 솔리디티 버전
3. 배포할 컨트랙트

# 솔리디티 코드 컴파일 (__test_sol_Counter 생성)

- solc 라이브러리 설치
  - npm i solc
- solc를 사용해서 코드 컴파일
  - npx solc --bin --abi ./test.sol
